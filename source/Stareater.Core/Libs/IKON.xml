<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Ikon</name>
    </assembly>
    <members>
        <member name="T:Ikon.Parser">
            <summary>
            Basic parser for texts streams with IKON syntax.
            </summary>
        </member>
        <member name="M:Ikon.Parser.#ctor(System.IO.TextReader)">
            <summary>
            Constructs parser without registerd value factories.
            </summary>
            <param name="reader">Input stream with IKON syntax</param>
        </member>
        <member name="M:Ikon.Parser.#ctor(System.IO.TextReader,System.Collections.Generic.IEnumerable{Ikon.IValueFactory})">
            <summary>
            Constructs parser and registers value factories to it.
            </summary>
            <param name="reader">Input stream with IKON syntax.</param>
            <param name="factories">Collection of value factories.</param>
        </member>
        <member name="M:Ikon.Parser.RegisterFactory(Ikon.IValueFactory)">
            <summary>
            Registers a value factory to the parser. If parser already
            has a factory with the same sign, it will be replaced.
            </summary>
            <param name="factory">A value factory.</param>
        </member>
        <member name="M:Ikon.Parser.ParseAll">
            <summary>
            Parses whole input stream.
            </summary>
            <returns>Queue of parsed IKON values.</returns>
        </member>
        <member name="M:Ikon.Parser.HasNext">
            <summary>
            Checks whether parser can read more IKON values from the input stream.
            </summary>
            <returns>True if it is possible.</returns>
        </member>
        <member name="M:Ikon.Parser.ParseNext">
            <summary>
            Parses and returns next IKON value from the input stream. 
            
            Throws System.IO.EndOfStreamException if end of
            the input stream is encountered while parsing.
            </summary>
            <returns>An IKON value</returns>
        </member>
        <member name="M:Ikon.Parser.TryParseNext">
            <summary>
            Trys to parse next IKON value from the input stream. 
            
            Throws System.FormatException if there is no value factory
            that can parse curren state of the input.
            </summary>
            <returns>Return an IKON value if there is one, null otherwise.</returns>
        </member>
        <member name="M:Ikon.Parser.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the System.IO.TextReader and optionally
            releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; 
            false to release only unmanaged resources.</param>
        </member>
        <member name="M:Ikon.Parser.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or
            resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Ikon.Parser.Factories">
            <summary>
            Collection on value factories.
            </summary>
        </member>
        <member name="P:Ikon.Parser.Reader">
            <summary>
            Input stream that is being parsed.
            </summary>
        </member>
        <member name="T:Ikon.ValueQueue">
            <summary>
            Represents a first-in, first-out collection of IKON values.
            </summary>
        </member>
        <member name="M:Ikon.ValueQueue.#ctor">
            <summary>
            Initializes a new empty instance of Ikon.ValueQueue.
            </summary>
        </member>
        <member name="M:Ikon.ValueQueue.#ctor(System.Collections.Generic.IEnumerable{Ikon.IkonBaseValue})">
            <summary>
            Initializes an instance of Ikon.ValueQueue filled with given elements.
            </summary>
            <param name="values">IKON values for populating the Ikon.ValueQueue.</param>
        </member>
        <member name="M:Ikon.ValueQueue.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A System.Collections.Generic.IEnumerator&lt;T&gt; that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Ikon.ValueQueue.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An System.Collections.IEnumerator object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Ikon.ValueQueue.CountOf(System.String)">
            <summary>
            Gets the number of elements on given type contained in the Ikon.ValueQueue.
            </summary>
            <param name="typeName">Type name of IKON values to count.</param>
            <returns>Number of elements in question.</returns>
        </member>
        <member name="M:Ikon.ValueQueue.Dequeue">
            <summary>
            Removes and returns the object at the beginning of the Ikon.ValueQueue.
            </summary>
            <returns>The object that is removed from the beginning of the Ikon.ValueQueue.</returns>
        </member>
        <member name="M:Ikon.ValueQueue.Dequeue(System.String)">
            <summary>
            Removes and returns the first element of the Ikon.ValueQueue with specified type name.
            </summary>
            <param name="typeName">Type name of IKON value to dequeue.</param>
            <returns>The IKON value.</returns>
        </member>
        <member name="M:Ikon.ValueQueue.Enqueue(Ikon.IkonBaseValue)">
            <summary>
            Adds an object to the end of the Ikon.ValueQueue.
            </summary>
            <param name="item">The object to add to the Ikon.ValueQueue. The value can be null for reference types.
            </param>
        </member>
        <member name="P:Ikon.ValueQueue.Count">
            <summary>
            Gets the number of elements contained in the Ikon.ValueQueue.
            </summary>
        </member>
        <member name="P:Ikon.ValueQueue.IsEmpty">
            <summary>
            Tests whether there are any elements in Ikon.ValueQueue.
            </summary>
        </member>
        <member name="T:Ikon.IValueFactory">
            <summary>
            Interface for IKON value factories usable by IKON parser.
            </summary>
        </member>
        <member name="M:Ikon.IValueFactory.Parse(Ikon.Parser)">
            <summary>
            Parses input for a IKON value.
            </summary>
            <param name="parser">IKON parser instance.</param>
            <returns>IKON value generated by factory.</returns>
        </member>
        <member name="P:Ikon.IValueFactory.Sign">
            <summary>
            Character that identifies value parcable by factory.
            </summary>
        </member>
        <member name="T:Ikon.IkonWriter">
            <summary>
            Base class for IKON composers. Composers transform IKON values to
            a text.
            </summary>
        </member>
        <member name="M:Ikon.IkonWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Constructs basic IKON composer.
            </summary>
            <param name="writer">Output stream.</param>
        </member>
        <member name="M:Ikon.IkonWriter.Write(System.String)">
            <summary>
            Appends a text to the current line. Text entered with this method
            is buffered and is not written immediately to the output stream.
            To finalize the buffered data (and write it to output stream) call
            either EndLine or WrtieLine.
            </summary>
            <param name="text">Raw text.</param>
        </member>
        <member name="M:Ikon.IkonWriter.WriteLine(System.String)">
            <summary>
            Appends a text to the current line and writes buffered line to the
            output stream.
            </summary>
            <param name="text">Raw text.</param>
        </member>
        <member name="M:Ikon.IkonWriter.EndLine">
            <summary>
            Writes buffered line to the output stream.
            </summary>
        </member>
        <member name="P:Ikon.IkonWriter.Writer">
            <summary>
            Output stream where IKON values are being written.
            </summary>
        </member>
        <member name="P:Ikon.IkonWriter.Indentation">
            <summary>
            Indentation level.
            </summary>
        </member>
        <member name="P:Ikon.IkonWriter.Line">
            <summary>
            Temporary line contents.
            </summary>
        </member>
        <member name="T:Ikon.IkonReader">
            <summary>
            Helper class with utility methods for parsing and composing
            text streams with IKON syntax.
            </summary>
        </member>
        <member name="F:Ikon.IkonReader.EndOfStreamResult">
            <summary>
            Value returned by System.IO.TextReader methods when the end of the stream is reached.
            </summary>
        </member>
        <member name="M:Ikon.IkonReader.#ctor(System.IO.TextReader)">
            <summary>
            Wraps TextReader with IkonReader
            </summary>
            <param name="reader">Input stream</param>
        </member>
        <member name="M:Ikon.IkonReader.Peek">
            <summary>
            Gets next character in the input stream without moving to the next.
            </summary>
        </member>
        <member name="M:Ikon.IkonReader.PeekNextNonwhite">
            <summary>
            Skips white space characters in the input stream and peeks the next character. 
            Throws System.FormatException if end of stream is reached before a non-white 
            character i found.
            </summary>
            <returns>A non-white character</returns>
        </member>
        <member name="M:Ikon.IkonReader.Read">
            <summary>
            Reads next character from the input stream.
            </summary>
            <returns>Read character.</returns>
        </member>
        <member name="M:Ikon.IkonReader.ReadWhile(System.Char[])">
            <summary>
            Reads characters from the input stream until the stopping condition is met. 
            </summary>
            <param name="readCondition">Characters that can be read.</param>
            <returns>Successfully read part of the stream.</returns>
        </member>
        <member name="M:Ikon.IkonReader.ReadWhile(System.Collections.Generic.ISet{System.Char})">
            <summary>
            Reads characters from the input stream until the stopping condition is met.
            </summary>
            <param name="readCondition">Set of characters that can be read.</param>
            <returns>Successfully read part of the stream.</returns>
        </member>
        <member name="M:Ikon.IkonReader.ReadWhile(System.Func{System.Char,Ikon.Utilities.ReadingDecision})">
            <summary>
            Reads characters from the input stream until the stopping condition is met.
            </summary>
            <param name="readingController">Returns whether character should be read
            (if predicate is true). When predicate evaluates to flase, reading stops.</param>
            <returns>Successfully read part of the stream.</returns>
        </member>
        <member name="M:Ikon.IkonReader.SkipWhiteSpaces">
            <summary>
            Skips consequentive whitespace characters from the input stream. 
            </summary>
            <returns>Descrtipion of the skipping process.</returns>
        </member>
        <member name="M:Ikon.IkonReader.SkipWhile(System.Char[])">
            <summary>
            Skips consequentive characters from the input stream.
            </summary>
            <param name="skippableCharacters">Character(s) that should be skipped.</param>
            <returns>Descrtipion of the skipping process.</returns>
        </member>
        <member name="M:Ikon.IkonReader.SkipWhile(System.Collections.Generic.ISet{System.Char})">
            <summary>
            Skips consequentive characters from the input stream.
            </summary>
            <param name="skippableCharacters">Set of characters that should be skipped.</param>
            <returns>Descrtipion of the skipping process.</returns>
        </member>
        <member name="M:Ikon.IkonReader.SkipWhile(System.Predicate{System.Char})">
            <summary>
            Skips consequentive characters from the input stream.
            </summary>
            <param name="skipCondition">Returns whether character should be skipped
            (if predicate is true). When predicate evaluates to flase, process stops.</param>
            <returns>Descrtipion of the skipping process.</returns>
        </member>
        <member name="M:Ikon.IkonReader.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the System.IO.TextReader and optionally
            releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; 
            false to release only unmanaged resources.</param>
        </member>
        <member name="M:Ikon.IkonReader.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or
            resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Ikon.IkonReader.Index">
            <summary>
            Index of the last read character.
            </summary>
        </member>
        <member name="P:Ikon.IkonReader.Line">
            <summary>
            Line of the last read character.
            </summary>
        </member>
        <member name="P:Ikon.IkonReader.Column">
            <summary>
            Column within the line of the last read character.
            </summary>
        </member>
        <member name="P:Ikon.IkonReader.PositionDescription">
            <summary>
            Gets text that describes position (line, column and index) of the last
            successfuly read character from the stream.
            </summary>
        </member>
        <member name="P:Ikon.IkonReader.HasNext">
            <summary>
            Indicates whether is it possible to read another character from the
            input stream.
            </summary>
        </member>
        <member name="T:Ikon.IkonBaseValue">
            <summary>
            Base class for IKON values.
            </summary>
        </member>
        <member name="M:Ikon.IkonBaseValue.To``1">
            <summary>
            Converts IKON value to specified type.
            </summary>
            <typeparam name="T">Target type</typeparam>
            <returns>Converted value</returns>
        </member>
        <member name="M:Ikon.IkonBaseValue.DoCompose(Ikon.IkonWriter)">
            <summary>
            Writes value's content to the output stream.
            </summary>
            <param name="writer">Wrapped around target output stream.</param>
        </member>
        <member name="M:Ikon.IkonBaseValue.Compose(Ikon.IkonWriter)">
            <summary>
            Writes an IKON value to the output stream.
            </summary>
            <param name="writer">Wrapped around target output stream.</param>
        </member>
        <member name="P:Ikon.IkonBaseValue.TypeName">
            <summary>
            Type name of the IKON value instance.
            </summary>
        </member>
        <member name="T:Ikon.Utilities.ReaderDoneReason">
            <summary>
            Describes whitespace skipping run.
            </summary>
        </member>
        <member name="F:Ikon.Utilities.ReaderDoneReason.EndOfStream">
            <summary>
            Skipping whitespaces encountered end of stream/input.
            </summary>
        </member>
        <member name="F:Ikon.Utilities.ReaderDoneReason.Successful">
            <summary>
            Skipping or reading was successful, character that doesn't satisfy
            skipping or reading conditions has been found.
            </summary>
        </member>
        <member name="T:Ikon.Utilities.Indentation">
            <summary>
            Indentation helper.
            </summary>
        </member>
        <member name="M:Ikon.Utilities.Indentation.ToString">
            <summary>
            Gets indentation string.
            </summary>
            <returns>Indentation string.</returns>
        </member>
        <member name="M:Ikon.Utilities.Indentation.Increase">
            <summary>
            Increases indentation by one level.
            </summary>
        </member>
        <member name="M:Ikon.Utilities.Indentation.Decrease">
            <summary>
            Decreases indentation by one level.
            </summary>
        </member>
        <member name="T:Ikon.Utilities.ReadingDecision">
            <summary>
            Describes action to be performed for certain character.
            </summary>
        </member>
        <member name="F:Ikon.Utilities.ReadingDecision.Character">
            <summary>
            Character in question or new character is supstitution is in to be perforemd.
            </summary>
        </member>
        <member name="F:Ikon.Utilities.ReadingDecision.Decision">
            <summary>
            The action to be performed.
            </summary>
        </member>
        <member name="M:Ikon.Utilities.ReadingDecision.#ctor(System.Char,Ikon.Utilities.CharacterAction)">
            <summary>
            Initializes reading decision result.
            </summary>
            <param name="character">Character in question or new character is supstitution is in to be perforemd.</param>
            <param name="decision">The action to be performed.</param>
        </member>
        <member name="T:Ikon.Utilities.CharacterAction">
            <summary>
            Action to be performed with a character.
            </summary>
        </member>
        <member name="F:Ikon.Utilities.CharacterAction.NoAction">
            <summary>
            Perform no action. Reader won't advance to the next character.
            </summary>
        </member>
        <member name="F:Ikon.Utilities.CharacterAction.Skip">
            <summary>
            Don't add anything to the result and continue reading.
            </summary>
        </member>
        <member name="F:Ikon.Utilities.CharacterAction.AcceptAsIs">
            <summary>
            Add the character as it is to the ressult.
            </summary>
        </member>
        <member name="F:Ikon.Utilities.CharacterAction.Supstitute">
            <summary>
            Add specified character to th result instead of read character.
            </summary>
        </member>
        <member name="F:Ikon.Utilities.CharacterAction.AllInputActions">
            <summary>
            Mask for input interpreting actions (accept, supstitute, skip).
            </summary>
        </member>
        <member name="F:Ikon.Utilities.CharacterAction.Stop">
            <summary>
            Reading is finished
            </summary>
        </member>
    </members>
</doc>
